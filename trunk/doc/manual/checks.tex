\section{Checks}
\fbox{Reword} The
\texttt{def-check}\index{check}\index{def-check@\texttt{def-check}}
form allows a higher-level description of tests.  The basic syntax of
the form is
\begin{tabbing}\hspace*{1cm}
\fbox{UPDATE}
%  (\textbf{de}\=\textbf{f-}\=\textbf{check} (\textit{name}
%  	\texttt{\&key} \= \textit{setup}
%  	     \textit{cleanup} \textit{fixtures})
%  \\ \>\> \textit{criterion}
%  \\ \>\texttt{\&rest} \textit{forms})
\end{tabbing}
The \textit{setup}, \textit{cleanup} and \textit{fixtures} forms are
passed as-is to the underlying \texttt{def-test}, and work the same
way.  The \textit{criterion} is a list or symbol specifying the
properties which should hold for the \textit{forms}.  When there are
no \textit{setup}, \textit{cleanup} or \textit{fixtures} arguments,
the \textit{name} may be given without parentheses.  Likewise, any
criterion consisting of a single symbol, e.g.\ \texttt{(:pass)}, may
be abbreviated as just the symbol without the parentheses, e.g.\
\texttt{:pass}.

\fbox{UPDATE BELOW} Where this list and the list in getting-started
differ, the latter is almost certainly correct.  But this order is
better, re-ored getting-started.

\def\criteriaGroup#1{\subsection{#1}}
\def\endcriteriaGroup{}
\def\criteriaDoc#1#2#3#4#5#6#7{%
\subsubsection{The \texttt{#2} check} 
#4\index{#1@\texttt{#2}}
\\ Syntax: \texttt{#3}
#6{#7}}
\def\noEx#1{}
\def\singleEx#1{\\Example: \texttt{#1}}
\def\multiEx#1{}
\def\tabbingEx#1{\\Example: \begin{tabbing}#1\end{tabbing}}
\input{../common/criteria}

\subsection{Compound forms}

\subsubsection{The \texttt{:apply} check}
This check applies some transforming function to a form, and applies
another check to the result.\index{apply@\texttt{:apply}}
\\ Syntax: \texttt{(:apply \textit{function} \textit{subcriterion})}
\\ Example: \texttt{(def-check applycheck (:apply cadr (:eql 10)) '(0 10 20))}

\subsubsection{The \texttt{:check-err} check}
This test verifies that evaluating a check throws an
error.\index{err@\texttt{:check-err}} The difference between
\texttt{:check-err} and \texttt{:err} is that the latter deals only
with evaluation of a form, whereas \texttt{:check-err} is more about
the unit testing process.  This form is mostly useful for temporarily
disregarding certain checks until some later fix, when they
\emph{won't} throw an error.
%
\\ Syntax: \texttt{(:check-err \textit{criterion})}
\\ Example: \texttt{(def-check check-err1 (:check-err :forms-eq) 'asdfgh (error "this should be caught"))}

\subsubsection{The \texttt{:progn} check}
This check evaluate a list of Lisp forms before evaluating the
remaining check criteria.
\\ Syntax: (\texttt{:progn} \textit{form} \ldots\ \textit{form} \textit{criterion})
\\ Example: Assuming that \texttt{zz} is defined as some variable,
\\ \hspace*{2em}\texttt{(def-check form1 (:progn (setf zz 3) (:eql 3)) zz)}

\subsubsection{The \texttt{:proj} check}
This check projects certain values from the current stack of forms
(numbering from 0) for another criterion.  This check is useful for
composing new checks as aliases.
\\ Syntax: \texttt{(:proj (\textit{num} \ldots\  \textit{num}) \textit{criterion})}
\\ Example: \texttt{(def-check proj-1 (:proj (0 2) :forms-eq) 'a 3 (car '(a b)))}

\subsubsection{The \texttt{:with} check}
\fbox{UNIMPLEMENTED --- is this still needed?}
\par
This check assumes that the next item is a list, whose contents are
expanded into the methods-and-forms.\index{with@\texttt{:with}} This
check is especially useful with the \texttt{def-check-cri\-ter\-ion}
command below.
\\ Syntax: \texttt{(:with \emph{criterion})}
\\ Example: The following two \texttt{def-check}s are equivalent.
\begin{verbatim}
  (def-check seq1
      (:seq (:predicate symbolp) (:eql 1) (:symbol d))
      '(a 1 d))
  (def-check with-seq1
      (:with (:seq (:predicate symbolp) (:eql 1) (:symbol d)))
      '(a 1 d))
\end{verbatim}

\subsection{Checks on lists}

\subsubsection{The \texttt{:each} check}
This check verifies that every member of the list to which a form
evaluates satisfies some other check.\index{each@\texttt{:each}}
\\ Syntax: \texttt{(:each \emph{criterion})}
\\ Example: \texttt{(def-check each1 (:each (:symbol a)) '(a a a a a))}

\subsubsection{The \texttt{:seq} check}
This check verifies, for each element $n$ of the $n$-element list to
which the form evaluates, that that element satisfies the respective
check.\index{seq@\texttt{:seq}}
\\ Syntax: \texttt{(:seq \emph{criteria} \ldots\ \emph{criteria})}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (de\=f-\=check seqcheck
\\ \>\>  (:seq (:predicate symbolp) (:eql 1) (:symbol d))
\\ \>  '(a 1 d))
\end{tabbing}}

\subsubsection{The \texttt{:permute} check}
The permute check verifies that some permutation of the list to which
the form evaluates satisfies some other check.
\index{permute@\texttt{:permute}}
\\ Syntax: \texttt{(:permute \textit{criterion}}
{\ttfamily\begin{tabbing}
\textrm{Examples:}\ \=(def-check permute1 (:permute (:each (:eq 'a))) '(a a))
\\ \> (de\=f-\=check permute2
\\ \> \> \> (:permute (:seq \=(:symbol b)
\\ \> \> \>             \>(:predicate symbolp)
\\ \> \> \>             \>(:predicate numberp)))
\\ \> \>'(1 a b))
\end{tabbing}}

\subsection{Checks on vectors}

\subsubsection{The \texttt{:across} check}
Like the \texttt{seq} check, but for vectors rather than
lists.\index{across@\texttt{:across}}
\\ Syntax: \texttt{(:across \emph{criteria} \ldots\ \emph{criteria})}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (de\=f-\=check across1
\\ \>\>  (:across (:predicate symbolp) (:eql 1))
\\ \>  (vector 'a 1))
\end{tabbing}}

\subsection{Checks on class instances}

\subsubsection{The \texttt{:slots} check} 
This check specifies checks for some or all of the slots of a class
member.\index{slots@\texttt{:slots}}
\\ Syntax: \texttt{(:slots  (\textit{slot} \textit{criterion})  \ldots\ (\textit{slot} \textit{criterion}))}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ \= (defc\=lass classcheck ()
\\ \> \> (\=(s1 :initarg :s1 :reader get-s1)
\\ \> \> \> (s2 :initarg :s2)
\\ \> \> \> (s3 :initarg :s3)))
\\ \> (def-check \=slot1
\\ \> \>  (:slots \=(s1 (:eql 10))
\\ \> \>  \>(s2 (:symbol zz))
\\ \> \>  \>(s3 (:seq \=(:symbol q) (:symbol w)
\\ \> \>  \> \> (:symbol e) (:symbol r))))
\\ \> \>  (m\=ake-instance 'classcheck
\\ \> \> \>  :s1 10 :s2 'zz :s3 '(q w e r)))
\end{tabbing}}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
