\section{Defining test criteria}
\fbox{THIS WHOLE SECTION NEEDS UPDATING} Do this last, or maybe John
can; it's all macrology.

NST provides a number of mechanism to define new criteria, offering
different levels of expressiveness, complexity and ease of use.
Choosing an appropriate mechanism requires some understanding of what
NST does at different points of test compilation and execution.

\subsection{Aliases over criteria}
The simplest mechanism for defining a new criterion involves simply
defining one criterion to rewrite as another using
\texttt{def-criterion-alias}:
%
{\ttfamily\begin{tabbing}
\textrm{Syntax: 
}(de\=f-criterion-alias (name \&rest args)
\\ \> [ documentation ]
\\ \> expansion)
\end{tabbing}}
The body of the expansion should be a Lisp form which, when evaluated,
returns an S-expression quoting the new criterion which the rewrite
should produce.  The \texttt{args} are passed as far Lisp macros: they
are not evaluated and are most typically comma-inserted into a
backquoted result.  For example:
\\ \texttt{(def-test-alias (:forms-eq) `(:predicate eq))}
\\ \texttt{(def-test-alias (:symbol name) `(:eq ',name))}

\subsection{Reporting forms}
The other two criteria-defining mechanisms define the expansion of a
criterion into Lisp.  For both of these mechanisms, the generated Lisp
is expected to return a \emph{test report}.  NST provides three
functions for building these outputs:
\begin{itemize}
\item\texttt{check-report}
\par\fbox{Fill in details}
\item\texttt{emit-failure}
\par\fbox{Fill in details}
\item\texttt{emit-warning}
\par\fbox{Fill in details}
\end{itemize}


\subsection{Basic checks on values}
Both \texttt{def-values-criterion} and \texttt{def-form-criterion}
should specify a quoted Lisp expression calculating a test report.
%
{\ttfamily\begin{tabbing}
\textrm{Syntax: 
}(de\=f-values-criterion (na\=me \=subcriteria-lambda-list
\\ \> \> \> test-forms-lambda-list
\\ \> \> \&key \= blurb-format
\\ \> \>        \> full-format
\\ \> \>        \> stack-transformer)
\\ \> expansion)
\end{tabbing}}
Comma-prefix names from the \texttt{subcriteria-lambda-list}, but do not
comma-prefix names from the \texttt{test-forms-lambda-list}.
Declarations are OK, but quote them.  Examples:
\begin{verbatim}
(def-value-check (:pass () (&rest chk))
  `(declare (ignorable chk))
  `(make-check-result))

(def-value-check (:eq (eq-form) (check-form))
  `(if (eq ,eq-form check-form)
     (make-check-result)
     (emit-failure :format "Not eq to ~s" :args '(,eq-form))))
\end{verbatim}
\par\fbox{Fill in details}

\subsection{General checks}
{\ttfamily\begin{tabbing}
\textrm{Syntax: 
}(de\=f-form-criterion (na\=me \=subcriteria-lambda-list
\\ \>\> \> test-forms-formal-parameter
\\ \>\> \&key \=stack-transformer
\\ \>\> \> blurb-format
\\ \>\> \> full-format)
\\ \> check-forms)
\end{tabbing}}
Comma-prefix all the names.  \texttt{test-forms-formal-parameter} must
be just a symbol.  Calls out to \texttt{continue-check} are useful;
its second argument must be a Lisp expression which will evaluate to a
list of values.
\begin{verbatim}
(def-control-check (:apply (transform criterion) forms)
  (continue-check criterion
		  `(multiple-value-list (apply #',transform ,forms))))
\end{verbatim}
\par\fbox{Fill in details}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
