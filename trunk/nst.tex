
\documentclass{article}
\title{A user's guide to NST}
\author{John Maraist\thanks{Smart Information Flow Technologies, 211 N.\ First St.\ Suite 300, Minneapolis, MN 55401; \textsl{jmaraist} at \textsl{sift.info}.}}

\begin{document}
\maketitle
\thispagestyle{empty}
\tableofcontents
\parskip 0.6em
\parindent 0pt
\section{Overview}
This document is a user's guide to the NST test framework.

For command-line examples, we give examples from the Franz Allegro
Lisp command line, using the \texttt{:nst} top-level alias; on other
systems the \texttt{run-nst-commands} macro is equivalent.

\section{Fixtures}
Fixtures are data structures and values which are used by name during
testing.  NST provides the ability to use fixtures across multiple
tests and test groups, and to inject fixtures into the runtime
namespace for debugging.

Fixtures are defined using the \texttt{def-fixtures} macro:
\begin{center}
\textbf{def-fixtures} \textit{name} \texttt{\&key}
\textit{bindings} \textit{uses} \textit{outer}
\textit{inner} \textit{documentation}
\end{center}
where
\begin{itemize}
\item \textit{name} is the name to be associated with this set of
  fixtures.
\item \textit{bindings} is a list of name/value lists, as is used for \texttt{let} blocks.
\item \textit{uses} is a list of the names used in the bindings which are defined in other fixtures.
\item \textit{outer} and \textit{inner} are lists of declarations to be includes in a \texttt{declare} respectively outside and inside of the let-binding in which the \textit{bindings} are used.
\item \textit{documentation} describes the fixture set.
\end{itemize}
Fixtures can be \emph{opened} into the interactive namespace for
debugging with the \texttt{:nst~:open} command:
\begin{verbatim}
  CL-USER(75): (nst:def-fixtures small-fixture
                  :bindings ((fix-var1 3) (fix-var2 'asdfg)))
  NIL
  CL-USER(76): (boundp 'fix-var1)
  NIL
  CL-USER(77): :nst :open small-fixture
  Opened fixture SMALL-FIXTURE.
  CL-USER(78): fix-var1
  3
  CL-USER(79): \end{verbatim}
%
Names defined in fixtures can be used in the tests of groups which
import that fixture.

\subsection*{Variations on fixture declarations}

The \texttt{def-capture/restore-fixtures} declaration binds nil to a
collection of variables in the extent of associated test groups.  This
form is useful when hiding some current state from standardized tests.
\begin{center}
\textbf{def-capture/restore-fixtures}
 \textit{name} \textit{variables}
\texttt{\&key} \textit{documentation}
\end{center}

\section{Test groups}
Groups of tests can be associated with fixture sets, stateful
initiatization, and stateful cleanup.  The syntax of a test group
declaration is:
\begin{center}
\textbf{def-test-group} \textit{name}
 \textit{fixture-sets} \texttt{\&rest} \textit{forms}
\end{center}
where
\begin{itemize}
\item\textit{name} is the name of this test group.
\item\textit{fixture-sets} is a list of the names of fixture
sets to be applied to the tests in this group.
\item\textit{forms} are one of the following:
\begin{itemize}
\item A test definition, described below.
\item Test group documentation, \texttt{(:documentation
    \textit{string})}~.
\item A setup form, \texttt{(:documentation \textit{setup})}~.  The
  setup form is run after inclusion of names from fixture sets, but
  before any tests from the group.  Individual tests should make no
  assumptions as to whether the setup is unique to that test, or
  whether it is shared among several tests of that group.
\item A cleanup form, \texttt{(:documentation \textit{cleanup})}~.
  The cleanup form is normally run after the setup completes; however
  the cleanup form will not be run if the setup form raises an error.
  When the user asks the runtime system to enter the debugger on an
  error, the cleanup form will not run unless the user explicitly
  enabled a resumption of the test routine from the debugger.  The
  cleanup form will be run in other circumstances, including at a
  user-requested break in testing at either failure or error.
\item A compile deferral supression, \texttt{(:defer-compile nil)}~.
  Normally the form of a test is evaluated at run time, so that e.g.\
  macros will be expanded according to the most current declaration.
  This flag will cause test forms to be compiled when the test is
  first loaded.
\end{itemize}
\end{itemize}
\section{Tests}
The basic form for defining a test is:
\begin{center}
\textbf{def-test} \textit{name}
 \texttt{\&rest} \textit{form} \textit{defer-compile}
\end{center}
where
\begin{itemize}
\item\textit{name} is the name of this test.
\item\textit{form} is the expression to be evaluated for this test.
\item\textit{defer-compile} functions as for the option on groups, but
  applied to this test only.
\end{itemize}
Test evaluation considers only whether the form evaluates to
\texttt{nil}, non-\texttt{nil}, or raises an error.
\section{Checks: higher-level tests}
The \texttt{def-check} form allows a higher-level description of
tests.  The basic syntax of the form is
\begin{center}
\textbf{def-check} \textit{name} \textit{method}
\end{center}
There are several test methods, some of which recur with further
methods:
\subsection{Simple checks}
\subsubsection{The \texttt{pass} check} 
This check always passes.
\\ Syntax: \texttt{pass}
\\ Example: \texttt{(def-check passing-test pass)}

\subsubsection{The \texttt{fail} check} 
This check always fails.
\\ Syntax: \texttt{fail}
\\ Example: \texttt{(def-check failing-test fail)}

\subsubsection{The \texttt{symbol} check} 
This test verifies that a form evaluates to some named symbol.
\\ Syntax: \texttt{symbol} \textit{symbol-name} \textit{form}
\\ Passing example: \texttt{(def-check sym1 symbol a (car '(a b c)))}
\\ Failing example: \texttt{(def-check sym1x symbol a (cadr '(a b c)))}

\subsubsection{The \texttt{eq} check} 
This test verifies that the form to be tested evaluates to a value
\texttt{eq}-identified with the value of some designated form.
\\ Syntax: \texttt{eq} \textit{correct-form} \textit{tested-form}
\\ Example: \texttt{(def-check eq1 eq 'b (cadr '(a b c)))}

\subsubsection{The \texttt{eql} check} 
This test verifies that the form to be tested evaluates to a value
\texttt{eql}-identified with the value of some designated form.
\\ Syntax: \texttt{eql} \textit{correct-form} \textit{tested-form}
\\ Example: \texttt{(def-check eql1 eql 2 (cadr '(1 2 3)))}

\subsubsection{The \texttt{forms-eq} check} 
This test verifies that two forms evaluate to \texttt{eq}-identified
values.
\\ Syntax: \texttt{forms-eq} \textit{form1} \textit{form2}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (def-check \=eqforms1
\\ \>  forms-eq (cadr '(a b c)) (caddr '(a c b)))
\end{tabbing}}

\subsubsection{The \texttt{forms-eql} check} 
This test verifies that two forms evaluate to \texttt{eql}-identified
values.
\\ Syntax: \texttt{forms-eql} \textit{form1} \textit{form2}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (def-check \=eqlforms1
\\ \>  forms-eq (cadr '(a 3 c)) (caddr '(a c 3)))
\end{tabbing}}

\subsubsection{The \texttt{predicate} check} 
This test applies some predicate function to a form, and verifies that
the result is non-null.
\\ Syntax: \texttt{predicate} \textit{function} \textit{form}
\\ Example: \texttt{(def-check pred1 predicate \#'numberp 3)}

\subsubsection{The \texttt{err} check} 
This test verifies that a form throws an error.
\\ Syntax: \texttt{err} \textit{form}
\\ Example: \texttt{(def-check err1 err (error "this should be caught"))}

\subsubsection{The \texttt{not} check} 
This check verifies that some other check fails (but does not throw an
error).
\\ Syntax: \texttt{not} \textit{method}
\\ Example: \texttt{(def-check not1 not symbol b 'a)}
\\In this example, the ``inner'' method is \texttt{symbol b 'a}\enspace.

\subsubsection{The \texttt{apply} check} 
This check applies some transforming function to a form, and applies
another check to the result.
\\ Syntax: \texttt{apply} \textit{function} \textit{method} \textit{form}
\\ Example: \texttt{(def-check applycheck apply \#'cadr eql 10 '(0 10 20))}
\subsection{Checks on lists}

\subsubsection{The \texttt{each} check} 
This check verifies that every member of the list to which a form
evaluates satisfies some other check.
\\ Syntax: \texttt{each} \textit{method} \textit{form}
\\ Example: \texttt{(def-check each1 each symbol a '(a a a a a))}

\subsubsection{The \texttt{seq} check} 
This check verifies, for each element $n$ of the $n$-element list to
which the form evaluates, that that element satisfies the respective
check.
\\ Syntax: \texttt{seq} \textit{method-1} \ldots\ \textit{method-$n$} \textit{form}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (def-check \=seqcheck
\\ \>  seq (predicate \#'symbolp) (eql 1) (symbol d)
\\ \>  '(a 1 d))
\end{tabbing}}

\subsubsection{The \texttt{permute} check} 
The permute check verifies that some permutation of the list to which
the form evaluates satisfies some other check. 
\\ Syntax: \texttt{permute} \textit{method} \textit{form}
{\ttfamily\begin{tabbing}
\textrm{Examples:}\ \=(def-check permute1 permute each eq 'a '(a a))
\\ \> (def-check \=permute2
\\ \> \>  permute seq \=(symbol b)
\\ \> \>              \>(predicate \#'symbolp)
\\ \> \>              \>(predicate \#'numberp)
\\ \> \>'(1 a b))
\end{tabbing}}

\subsection{Checks on vectors}
\subsubsection{The \texttt{across} check} 
Like the \texttt{seq} check, but for vectors rather than lists.
\\ Syntax: \texttt{across} \textit{method-1} \ldots\ \textit{method-$n$} \textit{form}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (def-check \=across1
\\ \>  across (predicate \#'symbolp) (eql 1)
\\ \>  (vector 'a 1))
\end{tabbing}}

\subsection{Checks on class instances}
\subsubsection{The \texttt{slots} check} 
This check specifies checks for some or all of the slots of a class
member.
\\ Syntax: \texttt{slots} (\textit{slot-1} \textit{method-1})  \ldots\ (\textit{slot-$n$} \textit{method-$n$}) \textit{form}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ \= (defc\=lass classcheck ()
\\ \> \> (\=(s1 :initarg :s1 :reader get-s1)
\\ \> \> \> (s2 :initarg :s2)
\\ \> \> \> (s3 :initarg :s3)))
\\ \> (def-check \=slot1
\\ \> \>  slots \=(s1 (eql 10))
\\ \> \>  \>(s2 (symbol zz))
\\ \> \>  \>(s3 (seq \=(symbol q) (symbol w)
\\ \> \>  \> \> (symbol e) (symbol r)))
\\ \> \>  (m\=ake-instance 'classcheck
\\ \> \> \>  :s1 10 :s2 'zz :s3 '(q w e r)))
\end{tabbing}}

\section{Integration with ASDF}
Try something like this following, where \texttt{PACKAGE} is where
your code lives, and \texttt{test-PACKAGE} is where your tests on that
code live.
\begin{verbatim}
(defmethod perform ((op test-op)
                    (system (eql (find-system :test-PACKAGE))))
  (eval (list (intern (symbol-name '#:run-nst-commands)
                      (find-package :nst))
              :p
              (quote (intern (symbol-name 'PACKAGE)
                             (find-package 'cl-user)))
              :run)))
\end{verbatim}

\section{The runtime system}
Use \texttt{(nst:run-nst-commands :help)}\footnote{Under Allegro, this
  can be abbreviated \texttt{:nst :help}\enspace.} to display a
summary of command to the runtime system.
\end{document}
