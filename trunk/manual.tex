
\documentclass{article}
\usepackage{makeidx}
\title{A user's guide to NST}
\author{John Maraist\thanks{Smart Information Flow Technologies, 211 N.\ First St.\ Suite 300, Minneapolis, MN 55401; \textsl{jmaraist} at \textsl{sift.info}.}}
\setcounter{tocdepth}{2}
\makeindex

\begin{document}
\maketitle
\thispagestyle{empty}
\tableofcontents
\parskip 0.6em
\parindent 0pt

\section*{Overview}
This document is the manual and users' guide to the NST test
framework.  NST is a unit test system which provides support for test
fixture data, stateful setup and cleanup of tests, grouping of tests,
and (we think!) a useful interface.  Suggestions and comments are
welcome; a list of known bugs and infelicities concludes this
document.  The file \texttt{nst-nst.lisp} in this distribution is our
debugging suite for this package, and contains many examples (some of
which we include in this document).

\section{Fixtures}
\label{fixtures}
Fixtures\index{fixtures} are data structures and values which may be
referred to by name during testing.  NST provides the ability to use
fixtures across multiple tests and test groups, and to inject fixtures
into the runtime namespace for debugging.

A set of fixtures is defined using the \texttt{def-fixtures}
macro:\index{def-fixtures@\texttt{def-fixtures}}
\begin{center}
\textbf{def-fixtures} \textit{name} \texttt{\&key}
\textit{bindings} \textit{uses} \textit{outer}
\textit{inner} \textit{documentation}
\end{center}
where
\begin{itemize}
\item \textit{name} is the name to be associated with this set of
  fixtures.
\item \textit{bindings} is a list of name/value lists, as is used for
  \texttt{let} blocks.
\item \textit{uses} is a list of the names of other fixture sets which
  this declaration assumes to be available.  This declaration is
  optional, but will supress some warnings.
\item \textit{outer} and \textit{inner} are lists of declarations to
  be included in a \texttt{declare} statement respectively outside and
  inside of the let-binding in which the \textit{bindings} are used.
\item \textit{documentation} describes the fixture set.
\end{itemize}
A fixture in one set may refer back to other fixtures in the same set
(\emph{\`a la} \texttt{let*}) but forward references are not allowed.

Examples:
\begin{verbatim}
(def-fixtures f1 :bindings ((c 3) (d 'asdfg)))
(def-fixtures f2 :uses (f1) :bindings ((d 4) (e 'asdfg) (f c)))
\end{verbatim}

\subsection{Alternate fixture definitions}
The
\texttt{def-capture/restore-fixtures}\index{def-capture/restore-fixtures@\texttt{def-capture/restore-fixtures}}
declaration binds \texttt{nil} to a collection of variables in the
extent of associated test groups.  This form is useful when hiding
some current state from standardized tests.
\begin{center}
\textbf{def-capture/restore-fixtures}
 \textit{name} \textit{variables}
\texttt{\&key} \textit{documentation}
\end{center}

\subsection{Anonymous fixture sets}
It is not necessary to name fixture sets; they may be given
anonymously in any situation where a fixture set name is allowed.  The
syntax of anonymous fixture sets
is:\index{fixtures@\texttt{:fixtures}}\index{fixtures!anonymous}
\begin{center}
\texttt{(:fixtures }\textit{(name form)}$^+$\texttt{ )}
\end{center}
The examples of Section~\ref{tests} show the use of anonymous fixture
sets.

\section{Test groups}
Groups of tests\index{group}\index{test group|see{group}} can be
associated with fixture sets, stateful initiatization, and stateful
cleanup.  The syntax of a test group declaration
is:\index{def-test-group@\texttt{def-test-group}}
\begin{center}
\textbf{def-test-group} \textit{name}
 \textit{fixture-sets} \texttt{\&rest} \textit{forms}
\end{center}
where
\begin{itemize}
\item\textit{name} is the name of this test group.
\item\textit{fixture-sets} is a list of fixture sets --- given by
  name, or as anonymous fixtures --- to be applied to the tests in
  this group.
\item\textit{forms} are one of the following:
\begin{itemize}
\item A test definition, described below.
\item Test group documentation, \texttt{(:documentation
    \textit{string})}~\index{documentation@\texttt{:documentation}}.
\item A setup form, \texttt{(:setup
    \textit{setup})}~\index{setup@\texttt{:setup}}.  The setup form is
  run after inclusion of names from fixture sets, but before any tests
  from the group.  Individual tests should make no assumptions as to
  whether the setup is unique to that test, or whether it is shared
  among several tests of that group.
\item A cleanup form, \texttt{(:cleanup
    \textit{cleanup})}~\index{cleanup@\texttt{:cleanup}}.  The
  cleanup form is normally run after the setup completes; however the
  cleanup form will not be run if the setup form raises an error.
  When the user asks the runtime system to enter the debugger on an
  error, the cleanup form will not run unless the user explicitly
  enabled a resumption of the test routine from the debugger.  The
  cleanup form will be run in other circumstances, including at a
  user-requested break in testing at either failure or error.
\item A compile deferral supression, \texttt{(:defer-compile
    nil)}~\index{defer-compile@\texttt{:defer-compile}}.  Normally the
  form of a test is evaluated at run time, so that e.g.\ macros will
  be expanded according to the most current declaration.  This flag
  will cause test forms to be compiled when the test is first loaded.
\end{itemize}
\end{itemize}

\section{Tests}
\label{tests}
The basic form for defining a
test\index{test}\index{def-test@\texttt{def-test}} within a group is:
\begin{center}
\textbf{def-test} \textit{name}
 \texttt{\&key} \textit{form} \textit{setup} \textit{cleanup} \textit{fixtures} \textit{defer-compile}
\end{center}
where
\begin{itemize}
\item\textit{name} is the name of this test.
\item\textit{form} is the expression to be evaluated for this test.
\item\textit{setup}\index{setup@\texttt{:setup}},
  \textit{cleanup}\index{cleanup@\texttt{:cleanup}} and
  \textit{defer-compile} all function as for the option on groups, but
  applied to this test only.
\item\textit{fixtures}\index{fixtures@\texttt{:fixtures}} allows
  fixture sets to be applied to a single test.
\end{itemize}
Test evaluation considers only whether the form evaluates to
\texttt{nil}, non-\texttt{nil}, or raises an error.

These examples assume that the fixture declarations of
Section~\ref{fixtures} are in effect:
\begin{verbatim}
(def-test-group small-tests ()
  (def-test test-with-eq  :form (eq 'a 'a))
  (def-test test-with-eql :form (eql 4 (+ 1 3))))
(def-test-group bindings (f1 (:fixtures zz 3 yy 5))
  (def-test bound0 :form (boundp 'c))
  (def-test bound1 :form (boundp 'zz))
  (def-test bound2 :form (eql yy 5)))
(def-test-group with-test-fixings ()
  (def-test fix0 :fixtures (f1)              :form (boundp 'c))
  (def-test fix1 :fixtures ((:fixtures x 3)) :form (boundp 'x)))
\end{verbatim}
Note that the \texttt{def-test} declarations are embedded within the
\texttt{def-test-group} declaration.

\section{Checks: higher-level tests}
The
\texttt{def-check}\index{check}\index{def-check@\texttt{def-check}}
form allows a higher-level description of tests.  The basic syntax of
the form is
\begin{center}
\textbf{def-check} \textit{name} \texttt{\&rest} \textit{methods-and-forms}
\end{center}
Generally speaking, the syntax of the \textit{methods-and-forms} are:
\begin{center}
\textit{transform} $\cdots$ \textit{transform} \textit{criteria} \textit{form}
\end{center}
where the \emph{transform}s are applied left-to-right to the
\emph{form}, which is then checked against the \emph{criteria}.
However, many of the criteria or transforms introduce other
interpretations of the \textit{methods-and-forms}.
\subsection{Basic checks}
\subsubsection{The \texttt{:pass} check} 
This check always passes.\index{pass@\texttt{:pass}}
\\ Syntax: \texttt{:pass}
\\ Example: \texttt{(def-check passing-test :pass)}

\subsubsection{The \texttt{:fail} check} 
This check always fails.\index{fail@\texttt{:fail}}
\\ Syntax: \texttt{:fail}
\\ Example: \texttt{(def-check failing-test :fail)}

\subsubsection{The \texttt{:symbol} check} 
This test verifies that a form evaluates to some named
symbol.\index{symbol@\texttt{:symbol}}
\\ Syntax: \texttt{:symbol} \textit{symbol-name} \textit{form}
\\ Passing example: \texttt{(def-check sym1 :symbol a (car '(a b c)))}
\\ Failing example: \texttt{(def-check sym1x :symbol a (cadr '(a b c)))}

\subsubsection{The \texttt{:eq} check} 
This test verifies that the form to be tested evaluates to a value
\texttt{eq}-identified with the value of some designated
form.\index{eq@\texttt{:eq}}
\\ Syntax: \texttt{:eq} \textit{correct-form} \textit{tested-form}
\\ Example: \texttt{(def-check eq1 :eq 'b (cadr '(a b c)))}

\subsubsection{The \texttt{:eql} check} 
This test verifies that the form to be tested evaluates to a value
\texttt{eql}-identified with the value of some designated
form.\index{eql@\texttt{:eql}}
\\ Syntax: \texttt{:eql} \textit{correct-form} \textit{tested-form}
\\ Example: \texttt{(def-check eql1 :eql 2 (cadr '(1 2 3)))}

\subsubsection{The \texttt{:forms-eq} check} 
This test verifies that two forms evaluate to \texttt{eq}-identified
values.\index{forms-eq@\texttt{:forms-eq}}
\\ Syntax: \texttt{:forms-eq} \textit{form1} \textit{form2}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (def-check \=eqforms1
\\ \>  :forms-eq (cadr '(a b c)) (caddr '(a c b)))
\end{tabbing}}

\subsubsection{The \texttt{:forms-eql} check} 
This test verifies that two forms evaluate to \texttt{eql}-identified
values.\index{forms-eql@\texttt{:forms-eql}}
\\ Syntax: \texttt{:forms-eql} \textit{form1} \textit{form2}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (def-check \=eqlforms1
\\ \>  :forms-eq (cadr '(a 3 c)) (caddr '(a c 3)))
\end{tabbing}}

\subsubsection{The \texttt{:predicate} check} 
This test applies some predicate function to a form, and verifies that
the result is non-null.\index{predicate@\texttt{:predicate}}
\\ Syntax: \texttt{:predicate} \textit{function} \textit{form}
\\ Example: \texttt{(def-check pred1 :predicate numberp 3)}

\subsubsection{The \texttt{:err} check} 
This test verifies that a form throws an
error.\index{err@\texttt{:err}}
\\ Syntax: \texttt{:err} \textit{form}
\\ Example: \texttt{(def-check err1 :err (error "this should be caught"))}

\subsection{Basic transforms}

\subsubsection{The \texttt{:not} check} 
This check verifies that some other check fails (but does not throw an
error).\index{not@\texttt{:not}}
\\ Syntax: \texttt{:not} \textit{method}
\\ Example: \texttt{(def-check not1 :not :symbol b 'a)}
\\In this example, the ``inner'' method is \texttt{:symbol b 'a}\enspace.

\subsubsection{The \texttt{:apply} check} 
This check applies some transforming function to a form, and applies
another check to the result.\index{apply@\texttt{:apply}}
\\ Syntax: \texttt{:apply} \textit{function} \textit{method} \textit{form}
\\ Example: \texttt{(def-check applycheck :apply cadr eql 10 '(0 10 20))}

\subsubsection{The \texttt{:with} check} 
This check assumes that the next item is a list, whose contents are
expanded into the methods-and-forms.\index{with@\texttt{:with}} This
check is especially useful with the \texttt{def-check-cri\-ter\-ion}
command below.
\\ Syntax: \texttt{:with} (\textit{methods-and-forms}) \textit{methods-and-forms}
\\ Example: The following two \texttt{def-check}s are equivalent.
\begin{verbatim}
  (def-check seq1
      :seq (:predicate symbolp) (:eql 1) (:symbol d)
      '(a 1 d))
  (def-check with-seq1
      :with (:seq (:predicate symbolp) (:eql 1) (:symbol d))
      '(a 1 d))
\end{verbatim}

\subsection{Checks on lists}

\subsubsection{The \texttt{:each} check} 
This check verifies that every member of the list to which a form
evaluates satisfies some other check.\index{each@\texttt{:each}}
\\ Syntax: \texttt{:each} \textit{method} \textit{form}
\\ Example: \texttt{(def-check each1 :each :symbol a '(a a a a a))}

\subsubsection{The \texttt{:seq} check} 
This check verifies, for each element $n$ of the $n$-element list to
which the form evaluates, that that element satisfies the respective
check.\index{seq@\texttt{:seq}}
\\ Syntax: \texttt{:seq} \textit{method-1} \ldots\ \textit{method-$n$} \textit{form}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (def-check \=seqcheck
\\ \>  :seq (:predicate symbolp) (:eql 1) (:symbol d)
\\ \>  '(a 1 d))
\end{tabbing}}

\subsubsection{The \texttt{:permute} check} 
The permute check verifies that some permutation of the list to which
the form evaluates satisfies some other check.
\index{permute@\texttt{:permute}}
\\ Syntax: \texttt{:permute} \textit{method} \textit{form}
{\ttfamily\begin{tabbing}
\textrm{Examples:}\ \=(def-check permute1 :permute :each :eq 'a '(a a))
\\ \> (def-check \=permute2
\\ \> \>  :permute :seq \=(:symbol b)
\\ \> \>              \>(:predicate symbolp)
\\ \> \>              \>(:predicate numberp)
\\ \> \>'(1 a b))
\end{tabbing}}

\subsection{Checks on vectors}
\subsubsection{The \texttt{:across} check} 
Like the \texttt{seq} check, but for vectors rather than
lists.\index{across@\texttt{:across}}
\\ Syntax: \texttt{:across} \textit{method-1} \ldots\ \textit{method-$n$} \textit{form}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ (def-check \=across1
\\ \>  :across (:predicate symbolp) (:eql 1)
\\ \>  (vector 'a 1))
\end{tabbing}}

\subsection{Checks on class instances}
\subsubsection{The \texttt{:slots} check} 
This check specifies checks for some or all of the slots of a class
member.\index{slots@\texttt{:slots}}
\\ Syntax: \texttt{:slots} (\textit{slot-1} \textit{method-1})  \ldots\ (\textit{slot-$n$} \textit{method-$n$}) \textit{form}
{\ttfamily\begin{tabbing}
\textrm{Example:}\ \= (defc\=lass classcheck ()
\\ \> \> (\=(s1 :initarg :s1 :reader get-s1)
\\ \> \> \> (s2 :initarg :s2)
\\ \> \> \> (s3 :initarg :s3)))
\\ \> (def-check \=slot1
\\ \> \>  :slots \=(s1 (:eql 10))
\\ \> \>  \>(s2 (:symbol zz))
\\ \> \>  \>(s3 (:seq \=(:symbol q) (:symbol w)
\\ \> \>  \> \> (:symbol e) (:symbol r)))
\\ \> \>  (m\=ake-instance 'classcheck
\\ \> \> \>  :s1 10 :s2 'zz :s3 '(q w e r)))
\end{tabbing}}

\subsection{Defining criteria aliases}
It is straightforward to introduce new testing criteria and
transformers for a project's local classes and data.  The
\texttt{def-check-criterion}\index{def-check-criterion@\texttt{def-check-criterion}}
command introduces a new \texttt{def-check} keyword which is
implemented by rewriting the remaining methods and forms of
the~\texttt{def-check}, roughly in the manner of Lisp macro expansion.
The syntax of \texttt{def-check-criterion} is:
\begin{center}
  \textbf{def-check-criterion} \textit{name} \texttt{\&key}
  \textit{documentation} \textit{args} \textit{rest}
  \textit{expansion}
\end{center}
where:
\begin{itemize}
\item\textit{documentation} is a documentation string.  As of this
  writing, NST does not actually install this string anywhere, but we
  do have very high hopes for the future.
\item\textit{args} provides a list of names used to expose names of
  subsequent methods and forms for use in the expansion.  At this time
  we cannot support lambda list keywords here; their use will produce
  undefined behavior (but which would most likely be very cryptic
  error messages).  By default, this is taken to be \textit{nil}.
\item\textit{rest} provides a name against which the remaining methods
  and forms (after those consumed by \textit{args}) may be exposed to
  the expansion.  When this argument is \emph{not} supplied, a
  noninterned symbol is used, and moreover these remaining methods and
  forms are appended to those given by the expansion.  Whenever this
  argument \emph{is} supplied, no such automatic append occurs, and it
  is assumed that the expansion makes some appropriate use of the
  keywords and forms bound to \textit{rest}.

  Note that the form being checked --- which is taken to be the last
  form in the \texttt{def-check} --- is never bound, neither to the
  name specified by \textit{rest} nor to any name in \textit{args};
  this form moreover remains the last form in the \texttt{def-check}.
\item\textit{expansion} is a form which, when evaluated, should return
  a list of \texttt{def-check} keywords and forms which will be taken
  as the expansion of \textit{name}.
\end{itemize}
Examples:
\begin{itemize}
\item\index{carcarcdr@\texttt{:carcarcdr}}
\begin{verbatim}
(def-check-criterion :carcarcdr :args (x y zs)
		     :expansion `(:all (:apply car :with ,x)
				       (:apply cadr :with ,y)
				       (:apply cddr :with ,zs)))
\end{verbatim}
  This criterion takes three arguments $x$, $y$ and $z$ from the list
  of methods and forms, and produces a test operating on lists.
  Specifically, all of three sub-checks are expected to hold for the
  list.
  \begin{enumerate}
  \item The first sub-check transforms the list to retrieve its first
    element, and then applies the check specified by $x$ to this
    result.
  \item The second sub-check transforms the list to retrieve its
    second element, and then applies the check specified by $y$ to
    this result.
  \item The third sub-check transforms the list to retrieve its second
    tail (the \texttt{cdr} of its \texttt{cdr}), and then applies the
    check specified by $xs$ to this sublist.
  \end{enumerate}
  A valid use of this criterion is:
\begin{verbatim}
  (def-check ccc1
      :carcarcdr (:eq 'a) (:eql 3) (:apply length :eql 2)
      '(a 3 2 1))
\end{verbatim}
\item Custom criteria are especially useful for defining checks on new
  class definitions:
\begin{verbatim}
  (defclass classcheck ()
     ((s1 :initarg :s1 :reader get-s1)
      (s2 :initarg :s2) (s3 :initarg :s3)))
  (def-check-criterion :cc
      :args (c1 c2 c3)
      :expansion `(:slots (s1 ,c1) (s2 ,c2) (s3 ,c3)))
  (def-check cc-1
      :cc (:eql 1) (:symbol p) (:eq 'd)
      (make-instance 'classcheck :s1 1 :s2 'p :s3 'd))
\end{verbatim}
\item Finally, this example shows a use of the \texttt{:rest}
  argument:
\begin{verbatim}
  (def-check-criterion :car-fits-any-but-first
      :args (x) :rest rr
      :expansion `(:apply car :any ,@rr))
\end{verbatim}
  This criterion operates on a list.  It expects the checked form to
  evaluate to a list whose first element satisfies at least one of the
  forms given after the \texttt{:car-fits-any-but-first}, excluding
  the first of these forms.  That first form would be bound to
  \texttt{x}, rather than being in \texttt{rr}.  So both of these
  tests succeed (note that the latter uses \texttt{:not}):
\begin{verbatim}
  (def-check cfabf1
      :car-fits-any-but-first (:eq 'c) (:eq 'a) (:eql 3)
                              (:apply length :eql 2)
      '(a 3 2 1))
  (def-check cfabf2
      :not
      :car-fits-any-but-first (:eq 'a) (:eq 'c) (:eql 3)
                              (:predicate listp)
      '(a 3 2 1))
\end{verbatim}
\end{itemize}

\subsection{Low-level check definitions}
While \texttt{def-check-criterion} should be completely adequate for
most extensions of \texttt{def-check}, some extensions require
lower-level access to the translation to \texttt{def-test}.  The
\texttt{def-check-form} command provides this access.  The syntax of
\texttt{def-check-form} is:
\begin{tabbing}
  ~~~~\textbf{def-}\=\textbf{check-form} \textit{name}
  \\ \> \texttt{\&optional} \textit{documentation}
  \\ \> \texttt{\&key} \= \textit{strip-suffix} \textit{args}
  \textit{require-min-bare-subforms}
  \\ \> \>  \textit{expose-subtests} \textit{expose-bare-subforms} \textit{body}
\end{tabbing}
Most of the standard check forms are defined using
\texttt{def-check-form}, and we refer the reader to file
\texttt{check.lisp} in this distribution for examples.

\section{The runtime system}
The runtime system provides several operations for scheduling and
running tests, and debugging failing and erring tests.  The operations
are accessible from the
\texttt{run-nst-commands}\index{run-nst-commands@\texttt{run-nst-commands}}
function.  Under Allegro, the top-level alias
\texttt{:nst}\index{nst@\texttt{:nst}} provides a shorthand to this
function; for the sake of brevity we use this shorthand below.

\subsection{Output control}
\subsubsection{The \texttt{:help} operation}
\index{help@\texttt{:help}}%
Shows a brief summary of the runtime system operations.
\\ Syntax: \texttt{:nst :help}

\subsubsection{The \texttt{:verbose} operation}
\index{verbose@\texttt{:verbose}}%
Sets whether the runtime system should show verbose output.
\\ Syntax: \texttt{:nst :verbose FORM}

\subsubsection{The \texttt{:debug} operation}
\index{debug@\texttt{:debug}}%
Sets whether NST debugging messages should be generated.
\\ Syntax: \texttt{:nst :debug BOOL}

\subsubsection{The \texttt{:summarize-scheduled} operation}
\index{summarize-scheduled@\texttt{:summarize-scheduled}}%
If \texttt{BOOL} evaluates to non-null, then the runtime system will
print a summary after running scheduled tests with \texttt{:run},
\texttt{:continue}, etc.
\\ Syntax: \texttt{:nst :summarize-scheduled BOOL}

\subsubsection{The \texttt{:summarize-single} operation}
\index{summarize-single@\texttt{:summarize-single}}%
If \texttt{BOOL} evaluates to non-null, then the runtime system will
print a summary after one-time test runs initiated by
\texttt{:run-test}, \texttt{:run-group}, etc.
\\ Syntax: \texttt{:nst :summarize-single BOOL}

\subsubsection{The \texttt{:dump} operation}
\index{dump@\texttt{:dump}}%
Prints the state of the test system.
\\ Syntax: \texttt{:nst :dump}

\subsection{Marking tests of interest for execution}
\label{nominating-tests}
NST allows tests to be marked for execution by the \texttt{:run}
command.  Tests can be marked by package or group, or as an individual
test.

\subsubsection{The \texttt{:p} operation}
\index{p@\texttt{:p}}%
Indicates that all tests in a particular package should be run.
\\ Syntax: \texttt{:nst :p PACKAGE}

\subsubsection{The \texttt{:g} operation}
\index{g@\texttt{:g}}%
Indicates that all tests in a particular group should be run.
\\ Syntax: \texttt{:nst :g GROUP}

\subsubsection{The \texttt{:t} operation}
\index{t@\texttt{:t}}%
Indicates that the named test should be run.
\\ Syntax: \texttt{:nst :t TEST}

\subsection{Test suite execution}
These commands control execution of tests selected by the commands of
the previous section.

\subsubsection{The \texttt{:run} operation}
\index{run@\texttt{:run}}%
Runs all marked tests.
\\ Syntax: \texttt{:nst :run}

\subsubsection{The \texttt{:continue} operation}
\index{continue@\texttt{:continue}}%
Resumes running tests after an interruption arising from one of the
three switch setting above.
\\ Syntax: \texttt{:nst :continue}

\subsubsection{The \texttt{:retry} operation}
\index{retry@\texttt{:retry}}%
Retries failed or error-raising tests from the last run.
\\ Syntax: \texttt{:nst :retry}

\subsubsection{The \texttt{:blurb} operation}
\index{blurb@\texttt{:blurb}}%
Describes the outcome of the last run of a test.
\\ Syntax: \texttt{:nst :blurb GROUPNAME TESTNAME}

\subsection{Controlling test suite execution behavior}
The following commands control options governing how the runtime
system should behave when a test fails or raises an error.

\subsubsection{The \texttt{:break-on-wrong} operation}
\index{break-on-wrong@\texttt{:break-on-wrong}}%
If \texttt{BOOL} evaluates to non-null, then a failing test will cause
test execution to pause.
\\ Syntax: \texttt{:nst :break-on-wrong BOOL}

\subsubsection{The \texttt{:break-on-error} operation}
\index{break-on-error@\texttt{:break-on-error}}%
If \texttt{BOOL} evaluates to non-null, then any error in a test run
will cause test execution to pause.
\\ Syntax: \texttt{:nst :break-on-error BOOL}

\subsubsection{The \texttt{:debug-on-error} operation}
\index{debug-on-error@\texttt{:debug-on-error}}%
If \texttt{BOOL} evaluates to non-null, then an error in a test run
will pause test execution and enter debug mode.
\\ Syntax: \texttt{:nst :debug-on-error BOOL}

\subsection{Test definition}
\subsubsection{The \texttt{:defer-test-compile} operation}
\index{defer-test-compile@\texttt{:defer-test-compile}}%
Sets whether tests defined subsequently should, by default, defer
compilation of their forms until actually running the test.  This
feature is useful when debugging code involving macros, but changing
this feature in the runtime system can lead to confusion.  It is
surely almost always the right thing to set this flag locally via
def-test-group and def-test.  In fact, this operation may be removed
in a future version of the runtime system.
\\ Syntax: \texttt{:nst :defer-test-compile BOOL}

\subsection{One-off execution}
The following commands allow one-time execution of tests without
altering the settings made by the commands of
Section~\ref{nominating-tests}.

\subsubsection{The \texttt{:run-package} operation}
\index{run-package@\texttt{:run-package}}%
Runs all of the tests in a package.
\\ Syntax: \texttt{:nst :run-package PACKAGE}

\subsubsection{The \texttt{:run-group} operation}
\index{run-group@\texttt{:run-group}}%
Runs all of the tests in a single group.
\\ Syntax: \texttt{:nst :run-group GROUP}

\subsubsection{The \texttt{:run-test} operation}
\index{run-test@\texttt{:run-test}}%
Runs a single test.
\\ Syntax: \texttt{:nst :run-test GROUP TEST}

\subsection{Opening fixtures}
The use of fixtures would make debugging tedious without access to
these named values.  Fortunately, it is straightforward to inject
these names into the runtime system.

\subsubsection{The \texttt{:open} operation}
\index{open@\texttt{:open}}%
Fixtures\index{fixtures!debugging} can be \emph{opened} into the
interactive namespace for debugging with the
\texttt{:nst~:open}\index{open@\texttt{:open}} command:
\\ Syntax: \texttt{:nst :open FIXTURE-NAME}
\\ Example:
\begin{verbatim}
  CL-USER(75): (nst:def-fixtures small-fixture
                  :bindings ((fix-var1 3) (fix-var2 'asdfg)))
  NIL
  CL-USER(76): (boundp 'fix-var1)
  NIL
  CL-USER(77): :nst :open small-fixture
  Opened fixture SMALL-FIXTURE.
  CL-USER(78): fix-var1
  3
  CL-USER(79): \end{verbatim}

\subsubsection{The \texttt{:open-used} operation}
\index{open-used@\texttt{:open-used}}%
If \texttt{BOOL} evaluates to non-null, then opening a fixture will
always also open the fixtures it uses.  Default is t.
\\ Syntax: \texttt{:nst :open-used BOOL}

\subsubsection{The \texttt{:reopen} operation}
\index{reopen@\texttt{:reopen}}%
If \texttt{BOOL} evaluates to non-null, then fixtures will be
re-opened e.g. when required multiple times by opening different
fixtures that use them.
\\ Syntax: \texttt{:nst :reopen BOOL}

%

\section{Integration with ASDF}
Try something like the following, where \texttt{PACKAGE} is where
your code lives, and \texttt{test-PACKAGE} is where your tests on that
code live.\index{ASDF}
\begin{verbatim}
(defmethod perform ((op test-op)
                    (system (eql (find-system :test-PACKAGE))))
  (eval (list (intern (symbol-name '#:run-nst-commands)
                      (find-package :sift.nst))
              :run-package
              (quote (intern (symbol-name 'PACKAGE)
                             (find-package 'cl-user))))))
\end{verbatim}

\section{Known issues}
If this list actually contained all of the bugs and shortcoming of
NST, I'd be one happy Lisper.  First, bugs\index{bugs} and
unimplemented features:
\begin{enumerate}
\item We do a poor job of printing the conditions that come back from
  erring tests.
\item There are still, sometimes, warnings from the use of fixture
  names in other fixtures.
\item We are not yet catching errors arising from
  \texttt{:cleanup}\index{cleanup@\texttt{:cleanup}} blocks.
\item Clobbering test/group names should be caught by the macros, not
  by the lower-level expansions arising from those methods.
\item There is much cruft here arising from my inexperience on getting
  names known at macro-expansion time communicated to other
  subsequently expanded macros.  I should clean up after myself.
\item In the runtime system, the implementations of
  \texttt{:blurb}\index{blurb@\texttt{:blurb}},
  \texttt{:open-used}\index{open-used@\texttt{:open-used}} and
  \texttt{:reopen}\index{reopen@\texttt{:reopen}} are questionable.
\end{enumerate}
Next, a wishlist\index{wishlist}:
\begin{enumerate}
\item There's probably some additional functionality that would be
  nice to have for
  \texttt{def-check}\index{def-check@\texttt{def-check}} --- other
  checks on lists, checks on other data structures.
\item Possibly,
  \texttt{run-nst-commands}\index{run-nst-commands@\texttt{run-nst-commands}}
  should be turned into a macro.
\item The \texttt{def-check}\index{def-check@\texttt{def-check}} macro
  should be able to provide better feedback when failing (the kind of
  failing that doesn't throw an error), not just at the time, but also
  when \texttt{:blurb}ing\index{blurb@\texttt{:blurb}} tests
  after-the-fact.
\item It would be nice to have some management of the warnings or
  errors when multiple fixtures get the same error.
\item It might be nice to have a
  \texttt{texinfo}\index{texinfo@\texttt{texinfo}} version of this
  user guide.
\end{enumerate}

\printindex
\end{document}
